/// @ 0.12.4
### {
  name: "CatchUp",
  version: "0.1.0",
  author: "Sharkey CatchUp authors",
  description: "Review missed notes in a time window"
}

@init(){ Ui:render(CatchUp:UI()) }

namespace CatchUp {
  let state = {
    context: "home",
    windowHours: 12,
    filters: { originals: true, replies: false, renotes: false },
    stats: { scanned: 0 }
  }

  @UI(){
    return Ui:C:page({
      title: "CatchUp",
      children: [
        Ui:C:container({ id: "authors" }),
        Ui:C:container({ id: "feed" }),
        Ui:C:container({ id: "toplinks" })
      ]
    })
  }

  @open(ctx, hours, filters){
    state.context = ctx
    state.windowHours = hours
    state.filters = filters
    CatchUp:refresh()
  }

  @refresh(){
    state.stats = { scanned: 0 }
    let res = CatchUp:fetchWindow(state.context, state.windowHours, state.filters)
    state.stats.scanned = res.items.len()
    CatchUp:renderAuthors(res.groups)
    CatchUp:renderFeed(res.groups)
    CatchUp:renderTopLinks(res.links)
  }

  @fetchWindow(ctx, hours, filters){
    let endTs = Time:now()
    let startTs = endTs - hours*3600*1000
    let acc = []
    let page = 0
    let cursor = null
    while page < 2 {
      let params = { limit: 100, withFiles: false, withRenotes: filters.renotes, withReplies: filters.replies }
      if cursor != null { params.untilId = cursor }
      params.sinceDate = startTs
      params.untilDate = endTs
      let ep = (ctx == 'home') ? 'notes/timeline' : 'notes/hybrid-timeline'
      let res = Mk:api(ep, params)
      if res.len() == 0 { break }
      acc.push(...res)
      cursor = res.last().id
      if res.last().createdAt < startTs { break }
      page += 1
    }

    let groups = {}
    let linkMap = {}
    for n in acc {
      if n.visibility == 'specified' { continue }
      let kind = n.renoteId ? (n.text ? 'quote' : 'renote') : (n.replyId ? 'reply' : 'original')
      if !filters.originals && kind == 'original' { continue }
      if !filters.replies && kind == 'reply' { continue }
      if !filters.renotes && (kind == 'renote' || kind == 'quote') { continue }
      if !groups.has(n.user.id) { groups[n.user.id] = [] }
      groups[n.user.id].push({ note:n, kind })
      let urls = Regex:find_all(URL_REGEX, n.text || '')
      for u in urls {
        let k = CatchUp:linkKey(u)
        linkMap[k] = (linkMap[k] || 0) + 1
      }
    }
    return { items: acc, groups: groups, links: linkMap }
  }

  @linkKey(u){
    let t = Url:parse(u)
    let host = (t.host || '').lower()
    let path = (t.path || '/')
    path = Regex:replace('/{2,}', '/', path)
    if path.len() > 1 && path.endsWith('/') { path = path.slice(0, path.len()-1) }
    return `{host}{path}`
  }

  @renderAuthors(g){
    Ui:get('authors').update({ children: [ Ui:C:text({ text: `Authors: {g.keys().len()}` }) ] })
  }

  @renderFeed(g){
    Ui:get('feed').update({ children: [ Ui:C:text({ text: `Feed items: {state.stats.scanned}` }) ] })
  }

  @renderTopLinks(m){
    let entries = m.entries().sort(@(a,b){ b[1]-a[1] }).slice(0,10)
    Ui:get('toplinks').update({ children: [ Ui:C:text({ text: `Top Links: {entries.len()}` }) ] })
  }
}

const URL_REGEX = /https?:\/\/[\w\-._~:\/\?#\[\]@!$&'()*+,;=%]+/
