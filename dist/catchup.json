{
  "type": "plugin",
  "data": "/// @ 0.12.4\n### {\n  name: \"CatchUp\",\n  version: \"0.1.0\",\n  author: \"Sharkey CatchUp authors\",\n  description: \"Review missed notes in a time window\"\n}\n\n@init(){ Ui:render(CatchUp.UI()) }\n\nconst CatchUp = {\n  state: {\n    context: \"home\",\n    windowHours: 12,\n    filters: { originals: true, replies: false, renotes: false },\n    stats: { scanned: 0 }\n  },\n\n  UI: @(){\n    return Ui:C:page({\n      title: \"CatchUp\",\n      children: [\n        Ui:C:container({ id: \"authors\" }),\n        Ui:C:container({ id: \"feed\" }),\n        Ui:C:container({ id: \"toplinks\" })\n      ]\n    })\n  },\n\n  open: @(ctx, hours, filters){\n    CatchUp.state.context = ctx\n    CatchUp.state.windowHours = hours\n    CatchUp.state.filters = filters\n    CatchUp.refresh()\n  },\n\n  refresh: @(){\n    CatchUp.state.stats = { scanned: 0 }\n    let res = CatchUp.fetchWindow(CatchUp.state.context, CatchUp.state.windowHours, CatchUp.state.filters)\n    CatchUp.state.stats.scanned = res.items.len()\n    CatchUp.renderAuthors(res.groups)\n    CatchUp.renderFeed(res.groups)\n    CatchUp.renderTopLinks(res.links)\n  },\n\n  fetchWindow: @(ctx, hours, filters){\n    let endTs = Time:now()\n    let startTs = endTs - hours*3600*1000\n    let acc = []\n    let page = 0\n    let cursor = null\n    while page < 2 {\n      let params = { limit: 100, withFiles: false, withRenotes: filters.renotes, withReplies: filters.replies }\n      if cursor != null { params.untilId = cursor }\n      params.sinceDate = startTs\n      params.untilDate = endTs\n      let ep = (ctx == 'home') ? 'notes/timeline' : 'notes/hybrid-timeline'\n      let res = Mk:api(ep, params)\n      if res.len() == 0 { break }\n      acc.push(...res)\n      cursor = res.last().id\n      if res.last().createdAt < startTs { break }\n      page += 1\n    }\n\n    let groups = {}\n    let linkMap = {}\n    for n in acc {\n      if n.visibility == 'specified' { continue }\n      let kind = n.renoteId ? (n.text ? 'quote' : 'renote') : (n.replyId ? 'reply' : 'original')\n      if !filters.originals && kind == 'original' { continue }\n      if !filters.replies && kind == 'reply' { continue }\n      if !filters.renotes && (kind == 'renote' || kind == 'quote') { continue }\n      if !groups.has(n.user.id) { groups[n.user.id] = [] }\n      groups[n.user.id].push({ note:n, kind })\n      let urls = Regex:find_all(URL_REGEX, n.text || '')\n      for u in urls {\n        let k = CatchUp.linkKey(u)\n        linkMap[k] = (linkMap[k] || 0) + 1\n      }\n    }\n    return { items: acc, groups: groups, links: linkMap }\n  },\n\n  linkKey: @(u){\n    let t = Url:parse(u)\n    let host = (t.host || '').lower()\n    let path = (t.path || '/')\n    path = Regex:replace('/{2,}', '/', path)\n    if path.len() > 1 && path.endsWith('/') { path = path.slice(0, path.len()-1) }\n    return `{host}{path}`\n  },\n\n  renderAuthors: @(g){\n    Ui:get('authors').update({ children: [ Ui:C:text({ text: `Authors: {g.keys().len()}` }) ] })\n  },\n\n  renderFeed: @(g){\n    Ui:get('feed').update({ children: [ Ui:C:text({ text: `Feed items: {CatchUp.state.stats.scanned}` }) ] })\n  },\n\n  renderTopLinks: @(m){\n    let entries = m.entries().sort(@(a,b){ b[1]-a[1] }).slice(0,10)\n    Ui:get('toplinks').update({ children: [ Ui:C:text({ text: `Top Links: {entries.len()}` }) ] })\n  }\n}\n\nconst URL_REGEX = /https?:\\/\\/[\\w\\-._~:\\/\\?#\\[\\]@!$&'()*+,;=%]+/\n"
}
